<?xml version='1.0' encoding='UTF-8'?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
			targetNamespace="https://github.com/ARCOS-System/ARCOS/XSD"
			xmlns="https://github.com/ARCOS-System/ARCOS/XSD"
			xmlns:common="https://github.com/ARCOS-System/ARCOS/XSD/Common"
            elementFormDefault="qualified"
			attributeFormDefault="unqualified"
            version="0.3.1">

	<xs:annotation>
	  <xs:documentation>
		Captures predefined, globally available domain rules. Each rule is fixed
		as predefined and can be referenced in project-specific specifications.
		
		Rule where target = Entity.Attribute
			type = RuleTypeEnum
			predefined = true
	  </xs:documentation>
	</xs:annotation>

	<xs:element name="PredefinedDomainRules">
    <xs:complexType>
      <xs:sequence>
        <!-- Optional legacy-friendly atomic rules -->
        <xs:element name="AtomicRules" type="PredefinedAtomicRules" minOccurs="0"/>
        <!-- New: expressions library -->
        <xs:element name="Expressions" type="PredefinedExpressions" minOccurs="0"/>
      </xs:sequence>
      <xs:attribute name="name"    type="xs:string" use="optional"/>
      <xs:attribute name="version" type="xs:string" use="optional"/>
    </xs:complexType>
	</xs:element>


  <!-- =========
       Atomic Rules (legacy-friendly, still useful)
       ========= -->
  <xs:complexType name="PredefinedAtomicRule">
    <xs:sequence>
      <xs:element name="Params" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Param" maxOccurs="unbounded">
              <xs:complexType>
                <xs:attribute name="name"  type="Identifier" use="required"/>
                <xs:attribute name="value" type="xs:string" use="required"/>
                <xs:attribute name="type"  type="xs:string" use="optional"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="Explain" type="xs:string" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="id"      type="Identifier" use="required"/>
    <xs:attribute name="label"   type="xs:string"   use="optional"/>
    <xs:attribute name="typeRef" type="xs:IDREF"    use="required"/>  <!-- points to voc:AtomicType/@id -->
    <xs:attribute name="target"  type="FieldPath"   use="optional"/>
    <xs:attribute name="version" type="xs:string"   use="optional"/>
  </xs:complexType>

  <xs:complexType name="PredefinedAtomicRules">
    <xs:sequence>
      <xs:element name="Rule" type="PredefinedAtomicRule" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>








  <!-- =========
       Shared primitives
       ========= -->
  <xs:simpleType name="Identifier">
    <xs:restriction base="xs:NCName"/>
  </xs:simpleType>

  <xs:simpleType name="FieldPath">
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="LogicalOpEnum">
    <xs:restriction base="xs:string">
      <xs:enumeration value="AND"/>
      <xs:enumeration value="OR"/>
      <xs:enumeration value="NOT"/>
      <xs:enumeration value="XOR"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="QuantifierOpEnum">
    <xs:restriction base="xs:string">
      <xs:enumeration value="AT_LEAST_N"/>
      <xs:enumeration value="AT_MOST_N"/>
      <xs:enumeration value="EXACTLY_N"/>
      <xs:enumeration value="FOR_EACH"/>
    </xs:restriction>
  </xs:simpleType>




  <!-- =========
       Predefined Expressions Library
       ========= -->
  <xs:complexType name="PredefinedExpression">
    <xs:sequence>
      <xs:element name="Label"   type="xs:string" minOccurs="0"/>
      <xs:element name="Explain" type="xs:string" minOccurs="0"/>
      <xs:element name="Targets" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Target" type="FieldPath" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="Expr" type="Expression"/>
    </xs:sequence>
    <xs:attribute name="id"     type="Identifier" use="required"/>
    <xs:attribute name="scope"  type="xs:string"  use="optional"/> <!-- field|record|collection|dataset (advisory) -->
    <xs:attribute name="version" type="xs:string" use="optional"/>
    <xs:attribute name="status"  type="xs:string" use="optional"/> <!-- e.g., stable, beta, deprecated -->
  </xs:complexType>

  <xs:complexType name="PredefinedExpressions">
    <xs:sequence>
      <xs:element name="Expression" type="PredefinedExpression" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>




  <!-- Expression = choice among node kinds (recursive) -->
  <xs:complexType name="Expression">
    <xs:choice>
      <xs:element name="Atomic"      type="AtomicNode"/>
      <xs:element name="Logical"     type="LogicalNode"/>
      <xs:element name="Conditional" type="ConditionalNode"/>
      <xs:element name="Quantifier"  type="QuantifierNode"/>
    </xs:choice>
  </xs:complexType>







  <!-- =========
       Expression Nodes (RAE)
       ========= -->

  <!-- Atomic: link to a known atomic type from vocabulary; supply params & target -->
  <xs:complexType name="AtomicNode">
    <xs:sequence>
      <xs:element name="Params" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Param" maxOccurs="unbounded">
              <xs:complexType>
                <xs:attribute name="name"  type="Identifier" use="required"/>
                <xs:attribute name="value" type="xs:string" use="required"/>
                <xs:attribute name="type"  type="xs:string" use="optional"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="Explain" type="xs:string" minOccurs="0"/>
    </xs:sequence>
    <!-- Reference to an AtomicType defined in the vocabulary's AtomicCatalogue -->
    <xs:attribute name="typeRef" type="xs:IDREF" use="required"/>
    <!-- Which field/record the atomic applies to (optional if inherent in the params) -->
    <xs:attribute name="target"  type="FieldPath" use="optional"/>
  </xs:complexType>

  <!-- Logical combination of expressions -->
  <xs:complexType name="LogicalNode">
    <xs:sequence>
      <xs:element name="Expr" type="Expression" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="op" type="LogicalOpEnum" use="required"/>
  </xs:complexType>

  <!-- Conditional: IF (predicate) THEN (then) [ELSE (else)] -->
  <xs:complexType name="ConditionalNode">
    <xs:sequence>
      <xs:element name="Predicate" type="Expression"/>
      <xs:element name="Then"      type="Expression"/>
      <xs:element name="Else"      type="Expression" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <!-- Quantifier: counting/iteration semantics -->
  <xs:complexType name="QuantifierNode">
    <xs:sequence>
      <xs:element name="Expr" type="Expression"/>
    </xs:sequence>
    <xs:attribute name="op"     type="QuantifierOpEnum" use="required"/>
    <xs:attribute name="n"      type="xs:nonNegativeInteger" use="optional"/>
    <xs:attribute name="domain" type="FieldPath" use="optional"/> <!-- e.g., Order.items[] -->
    <xs:attribute name="note"   type="xs:string" use="optional"/>
  </xs:complexType>
















</xs:schema>





